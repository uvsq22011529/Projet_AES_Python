# Bibliothèque NumPy
import numpy as np

# Table de substitution
Sbox = (
            0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,
            0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,
            0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,
            0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,
            0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,
            0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,
            0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,
            0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,
            0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,
            0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,
            0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,
            0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,
            0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,
            0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,
            0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,
            0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16
            )

# Table de correspondance
rcon = ( 
            0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a,
            0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39,
            0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a,
            0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8,
            0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef,
            0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc,
            0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b,
            0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3,
            0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94,
            0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20,
            0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35,
            0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f,
            0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04,
            0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63,
            0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd,
            0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d
)

# Table de Rijndael utilisée dans la substitution de bytes pour remplacer chaque octet par 
# un autre octet en utilisant une multiplication par 3.
multiplication_by_2 = (
            0x00,0x02,0x04,0x06,0x08,0x0a,0x0c,0x0e,0x10,0x12,0x14,0x16,0x18,0x1a,0x1c,0x1e,
            0x20,0x22,0x24,0x26,0x28,0x2a,0x2c,0x2e,0x30,0x32,0x34,0x36,0x38,0x3a,0x3c,0x3e,
            0x40,0x42,0x44,0x46,0x48,0x4a,0x4c,0x4e,0x50,0x52,0x54,0x56,0x58,0x5a,0x5c,0x5e,
            0x60,0x62,0x64,0x66,0x68,0x6a,0x6c,0x6e,0x70,0x72,0x74,0x76,0x78,0x7a,0x7c,0x7e,
            0x80,0x82,0x84,0x86,0x88,0x8a,0x8c,0x8e,0x90,0x92,0x94,0x96,0x98,0x9a,0x9c,0x9e,
            0xa0,0xa2,0xa4,0xa6,0xa8,0xaa,0xac,0xae,0xb0,0xb2,0xb4,0xb6,0xb8,0xba,0xbc,0xbe,
            0xc0,0xc2,0xc4,0xc6,0xc8,0xca,0xcc,0xce,0xd0,0xd2,0xd4,0xd6,0xd8,0xda,0xdc,0xde,
            0xe0,0xe2,0xe4,0xe6,0xe8,0xea,0xec,0xee,0xf0,0xf2,0xf4,0xf6,0xf8,0xfa,0xfc,0xfe,
            0x1b,0x19,0x1f,0x1d,0x13,0x11,0x17,0x15,0x0b,0x09,0x0f,0x0d,0x03,0x01,0x07,0x05,
            0x3b,0x39,0x3f,0x3d,0x33,0x31,0x37,0x35,0x2b,0x29,0x2f,0x2d,0x23,0x21,0x27,0x25,
            0x5b,0x59,0x5f,0x5d,0x53,0x51,0x57,0x55,0x4b,0x49,0x4f,0x4d,0x43,0x41,0x47,0x45,
            0x7b,0x79,0x7f,0x7d,0x73,0x71,0x77,0x75,0x6b,0x69,0x6f,0x6d,0x63,0x61,0x67,0x65,
            0x9b,0x99,0x9f,0x9d,0x93,0x91,0x97,0x95,0x8b,0x89,0x8f,0x8d,0x83,0x81,0x87,0x85,
            0xbb,0xb9,0xbf,0xbd,0xb3,0xb1,0xb7,0xb5,0xab,0xa9,0xaf,0xad,0xa3,0xa1,0xa7,0xa5,
            0xdb,0xd9,0xdf,0xdd,0xd3,0xd1,0xd7,0xd5,0xcb,0xc9,0xcf,0xcd,0xc3,0xc1,0xc7,0xc5,
            0xfb,0xf9,0xff,0xfd,0xf3,0xf1,0xf7,0xf5,0xeb,0xe9,0xef,0xed,0xe3,0xe1,0xe7,0xe5
)

# Table de Rijndael utilisée dans la substitution de bytes pour remplacer chaque octet par 
# un autre octet en utilisant une multiplication par 3.
multiplication_by_3 = (
            0x00,0x03,0x06,0x05,0x0c,0x0f,0x0a,0x09,0x18,0x1b,0x1e,0x1d,0x14,0x17,0x12,0x11,
            0x30,0x33,0x36,0x35,0x3c,0x3f,0x3a,0x39,0x28,0x2b,0x2e,0x2d,0x24,0x27,0x22,0x21,
            0x60,0x63,0x66,0x65,0x6c,0x6f,0x6a,0x69,0x78,0x7b,0x7e,0x7d,0x74,0x77,0x72,0x71,
            0x50,0x53,0x56,0x55,0x5c,0x5f,0x5a,0x59,0x48,0x4b,0x4e,0x4d,0x44,0x47,0x42,0x41,
            0xc0,0xc3,0xc6,0xc5,0xcc,0xcf,0xca,0xc9,0xd8,0xdb,0xde,0xdd,0xd4,0xd7,0xd2,0xd1,
            0xf0,0xf3,0xf6,0xf5,0xfc,0xff,0xfa,0xf9,0xe8,0xeb,0xee,0xed,0xe4,0xe7,0xe2,0xe1,
            0xa0,0xa3,0xa6,0xa5,0xac,0xaf,0xaa,0xa9,0xb8,0xbb,0xbe,0xbd,0xb4,0xb7,0xb2,0xb1,
            0x90,0x93,0x96,0x95,0x9c,0x9f,0x9a,0x99,0x88,0x8b,0x8e,0x8d,0x84,0x87,0x82,0x81,
            0x9b,0x98,0x9d,0x9e,0x97,0x94,0x91,0x92,0x83,0x80,0x85,0x86,0x8f,0x8c,0x89,0x8a,
            0xab,0xa8,0xad,0xae,0xa7,0xa4,0xa1,0xa2,0xb3,0xb0,0xb5,0xb6,0xbf,0xbc,0xb9,0xba,
            0xfb,0xf8,0xfd,0xfe,0xf7,0xf4,0xf1,0xf2,0xe3,0xe0,0xe5,0xe6,0xef,0xec,0xe9,0xea,
            0xcb,0xc8,0xcd,0xce,0xc7,0xc4,0xc1,0xc2,0xd3,0xd0,0xd5,0xd6,0xdf,0xdc,0xd9,0xda,
            0x5b,0x58,0x5d,0x5e,0x57,0x54,0x51,0x52,0x43,0x40,0x45,0x46,0x4f,0x4c,0x49,0x4a,
            0x6b,0x68,0x6d,0x6e,0x67,0x64,0x61,0x62,0x73,0x70,0x75,0x76,0x7f,0x7c,0x79,0x7a,
            0x3b,0x38,0x3d,0x3e,0x37,0x34,0x31,0x32,0x23,0x20,0x25,0x26,0x2f,0x2c,0x29,0x2a,
            0x0b,0x08,0x0d,0x0e,0x07,0x04,0x01,0x02,0x13,0x10,0x15,0x16,0x1f,0x1c,0x19,0x1a
)

# Table de Rijndael utilisée dans la substitution de bytes pour remplacer chaque octet par 
# un autre octet en utilisant une multiplication par 9.
multiplication_by_9 = (
            0x00,0x09,0x12,0x1b,0x24,0x2d,0x36,0x3f,0x48,0x41,0x5a,0x53,0x6c,0x65,0x7e,0x77,
            0x90,0x99,0x82,0x8b,0xb4,0xbd,0xa6,0xaf,0xd8,0xd1,0xca,0xc3,0xfc,0xf5,0xee,0xe7,
            0x3b,0x32,0x29,0x20,0x1f,0x16,0x0d,0x04,0x73,0x7a,0x61,0x68,0x57,0x5e,0x45,0x4c,
            0xab,0xa2,0xb9,0xb0,0x8f,0x86,0x9d,0x94,0xe3,0xea,0xf1,0xf8,0xc7,0xce,0xd5,0xdc,
            0x76,0x7f,0x64,0x6d,0x52,0x5b,0x40,0x49,0x3e,0x37,0x2c,0x25,0x1a,0x13,0x08,0x01,
            0xe6,0xef,0xf4,0xfd,0xc2,0xcb,0xd0,0xd9,0xae,0xa7,0xbc,0xb5,0x8a,0x83,0x98,0x91,
            0x4d,0x44,0x5f,0x56,0x69,0x60,0x7b,0x72,0x05,0x0c,0x17,0x1e,0x21,0x28,0x33,0x3a,
            0xdd,0xd4,0xcf,0xc6,0xf9,0xf0,0xeb,0xe2,0x95,0x9c,0x87,0x8e,0xb1,0xb8,0xa3,0xaa,
            0xec,0xe5,0xfe,0xf7,0xc8,0xc1,0xda,0xd3,0xa4,0xad,0xb6,0xbf,0x80,0x89,0x92,0x9b,
            0x7c,0x75,0x6e,0x67,0x58,0x51,0x4a,0x43,0x34,0x3d,0x26,0x2f,0x10,0x19,0x02,0x0b,
            0xd7,0xde,0xc5,0xcc,0xf3,0xfa,0xe1,0xe8,0x9f,0x96,0x8d,0x84,0xbb,0xb2,0xa9,0xa0,
            0x47,0x4e,0x55,0x5c,0x63,0x6a,0x71,0x78,0x0f,0x06,0x1d,0x14,0x2b,0x22,0x39,0x30,
            0x9a,0x93,0x88,0x81,0xbe,0xb7,0xac,0xa5,0xd2,0xdb,0xc0,0xc9,0xf6,0xff,0xe4,0xed,
            0x0a,0x03,0x18,0x11,0x2e,0x27,0x3c,0x35,0x42,0x4b,0x50,0x59,0x66,0x6f,0x74,0x7d,
            0xa1,0xa8,0xb3,0xba,0x85,0x8c,0x97,0x9e,0xe9,0xe0,0xfb,0xf2,0xcd,0xc4,0xdf,0xd6,
            0x31,0x38,0x23,0x2a,0x15,0x1c,0x07,0x0e,0x79,0x70,0x6b,0x62,0x5d,0x54,0x4f,0x46
)

def format_hex(entier):
    """Convertit l'entier donné en entrée en chaine de caractères hexdécimale"""
    temp = hex(entier)[2:]
    if len(temp) == 1:
        temp = '0' + temp
    return temp


def RotWord(tab):
    """Utilise la fonction "roll()" de la bibliothèque NumPy pour décaler les éléments du
    tableau d'une position vers la gauche"""
    return np.roll(tab,-1)


def SubWord(tab):
    """Effectue une substitution de chaque élément du tableau en utilisant la table
    de substitution Sbox"""
    return np.array([format_hex(Sbox[int(elem, 16)]) for elem in tab])

def Rcon(entier):
    """Prend un entier en entrée et renvoie un tableau de 4 octets avec les 3 octets les moins 
    significatifs mis à 0."""
    return np.array([format_hex(rcon[entier]), format_hex(0x00), format_hex(0x00), format_hex(0x00)])


def create_key(key):
    """Prend une clé en entrée sous forme de chaîne de caractères hexadécimale et renvoie un tableau 4x4 de cette clé"""
    return np.array([key[i]+key[i+1] for i in range(0, len(key), 2)]).reshape(4,4, order='F') # le 'F' permet de spécifier que les 
                                                                                              # éléments du tableau doivent être disposés 
                                                                                              # dans l'ordre de colonne

def XorWord(tab1, tab2):
    """Utilise la bibliothèque NumPy pour effectuer une opération de XOR (OU exclusif) entre deux tableaux tab1 et tab2
    contenant des éléments représentant des valeurs hexadécimales"""
    return np.array([format_hex(int(tab1[i],16)^int(tab2[i],16)) for i in range(4)])


def keyExpansion(key):
    """Prend en entrée une clé sous forme de chaîne de caractères hexadécimale puis s'occupe de créer l'expansion 
    de la clé en fonction des tours"""
    the_key = create_key(key)
    for i in range(1, 11):
        x = the_key[:, -1] #Recuperre la derniere colonne de la cle
        x = RotWord(x)
        x = SubWord(x)
        x = XorWord(x, the_key[:, -4])
        x = XorWord(x, Rcon(i))
        the_key = np.c_[the_key, x]
        for _ in range(3):
            the_key = np.c_[the_key, XorWord(the_key[:, -1], the_key[:, -4])]
    return the_key


def printState(text):
    """Transforme un texte en une clé hexadécimale et la met sous forme de tableau 4x4."""
    key = ""
    for i in text:
        key+= format_hex(ord(i))
    return create_key(key)

def subBytes(etat):
    """La fonction prend en entrée un tableau 4x4 représentant l'état actuel et effectue la substitution de bytes 
    en utilisant la fonction "SubWord()" sur chaque élément de l'état"""
    etat_change =  np.copy(etat)
    for i in range(len(etat_change)):
        etat_change[i] = SubWord(etat[i])
    return etat_change

def ShiftRows(etat):
    """La fonction prend en entrée un tableau 4x4 représentant l'état actuel et applique une rotation horizontale de chaque ligne de 
    l'état en fonction de l'indice de la ligne. Plus précisément, la première ligne n'est pas modifiée, la deuxième ligne est décalée 
    d'une position vers la gauche, la troisième ligne est décalée de deux positions vers la gauche et la quatrième ligne est décalée de 
    trois positions vers la gauche."""
    etat_change =  np.copy(etat)
    for i in range(len(etat)):
        etat_change[i] = np.roll(etat[i],-i)
    return etat_change

def MixColumns(etat):
    """Cette fonction implémente l'étape de mélange de colonnes de l'algorithme AES. 
    Elle prend en entrée un état sous forme d'une matrice 4x4, effectue des opérations 
    arithmétiques sur chaque colonne, et renvoie l'état résultant.

    Plus précisément, la fonction effectue les opérations suivantes pour chaque colonne de l'état :

    - Elle multiplie le premier élément par 2, le deuxième élément par 3, le troisième élément par 1, 
    et le quatrième élément par 1.
    - Elle additionne les quatre produits obtenus, modulo 256.
    - Enfin, elle remplace chaque élément de la colonne par le résultat obtenu.

    Cette étape permet de mélanger les bits dans chaque colonne, de sorte que les bits d'un octet affectent 
    les bits de tous les autres octets de la même colonne."""
    etat_change = np.copy(etat)
    for i in range(4):
        un0, un1, un2, un3 = etat[0, i], etat[1, i], etat[2, i], etat[3, i]
        etat_change[0, i] = format_hex(multiplication_by_2[int(un0, 16)]^multiplication_by_3[int(un1, 16)]^int(un2, 16)^int(un3, 16))
        etat_change[1, i] = format_hex(multiplication_by_2[int(un1, 16)]^multiplication_by_3[int(un2, 16)]^int(un0, 16)^int(un3, 16))
        etat_change[2, i] = format_hex(multiplication_by_2[int(un2, 16)]^multiplication_by_3[int(un3, 16)]^int(un0, 16)^int(un1, 16))
        etat_change[3, i] = format_hex(multiplication_by_2[int(un3, 16)]^multiplication_by_3[int(un0, 16)]^int(un2, 16)^int(un1, 16))
    return etat_change

def AddRoundKey(etat, round):
    """La fonction prend en entrée un état et une clé de ronde (aussi appelée clé d'expansion), et retourne l'état résultant après avoir effectué 
    un XOR entre chaque colonne de la clé de ronde et la colonne correspondante de l'état. Cela permet de mélanger la clé et l'état avant de passer
    à l'étape suivante."""
    etat_change = np.copy(etat)
    for i in range(len(etat)):
        etat_change[i] = XorWord(etat[i], round[i])
    return etat_change

def printStateInverse(message_chiffre):
    """ Retourne le message chiffré précedemment en bloc d'état de 16 bits en héxadecimal à un message en texte """
    text = ""
    message_chiffre = message_chiffre.reshape(16, order='F')
    for i in message_chiffre:
        text+= chr(int(i, 16))
    return text

def encrypt(texte, key):
    """Effectue le chiffrement AES complet en utilisant les fonctions précédemment définies. 
    La fonction prend en entrée le texte à chiffrer et la clé puis retourne le message chiffré."""
    key = keyExpansion(key)
    message_crypte = printState(texte)
    message_crypte = AddRoundKey(message_crypte, key[:, :4])
    for i in range(1, 10):
        message_crypte = subBytes(message_crypte)
        message_crypte = ShiftRows(message_crypte)
        message_crypte = MixColumns(message_crypte)
        message_crypte = AddRoundKey(message_crypte, key[:, i*4:i*4+4])
    message_crypte = subBytes(message_crypte)
    message_crypte = ShiftRows(message_crypte)
    message_crypte = AddRoundKey(message_crypte, key[:, -4:])
    return message_crypte


# Test de la fonction de chiffrement
texte = 'This is one text'
key = '2b7e151628aed2a6abf7158809cf4f3c'
print('Le message chiffré obtenu est :\n', printStateInverse(encrypt(texte, key)))



        





